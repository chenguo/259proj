% THIS IS SIGPROC-SP.TEX - VERSION 3.1
% WORKS WITH V3.2SP OF ACM_PROC_ARTICLE-SP.CLS
% APRIL 2009
%
% It is an example file showing how to use the 'acm_proc_article-sp.cls' V3.2SP
% LaTeX2e document class file for Conference Proceedings submissions.
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V3.2SP) *DOES NOT* produce:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) Page numbering
% ---------------------------------------------------------------------------------------------------------------
% It is an example which *does* use the .bib file (from which the .bbl file
% is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission,
% you need to 'insert'  your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% Questions regarding SIGS should be sent to
% Adrienne Griscti ---> griscti@acm.org
%
% Questions/suggestions regarding the guidelines, .tex and .cls files, etc. to
% Gerald Murray ---> murray@hq.acm.org
%
% For tracking purposes - this is V3.1SP - APRIL 2009

\documentclass{acm_proc_article-sp}

\begin{document}
%TODO
\title{Comparing Power Optimizations in the Reorder Buffer}
%
% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

\numberofauthors{3} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
\author{
% You can go ahead and credit any number of authors here,
% e.g. one 'row of three' or two rows (consisting of one row of three
% and a second row of one, two or three).
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%
% 1st. author
\alignauthor
Chen Guo\\
       \affaddr{UCLA Computer Science Department}\\
       \affaddr{4732 Boelter Hall}\\
       \affaddr{Los Angeles, CA 90095}\\
% 2nd. author
\alignauthor
Alexander Edwards\\
       \affaddr{UCLA Computer Science Department}\\
       \affaddr{4732 Boelter Hall}\\
       \affaddr{Los Angeles, CA 90095}\\
% 3rd. author
\alignauthor
Henry Hsieh\\
       \affaddr{UCLA Computer Science Department}\\
       \affaddr{4732 Boelter Hall}\\
       \affaddr{Los Angeles, CA 90095}\\
}
% There's nothing stopping you putting the seventh, eighth, etc.
% author on the opening page (as the 'third row') but we ask,
% for aesthetic reasons that you place these 'additional authors'
% in the \additional authors block, viz.
% Just remember to make sure that the TOTAL number of authors
% is the number that will appear on the first page PLUS the
% number that will appear in the \additionalauthors section.

\maketitle
\begin{abstract}
	In an effort to increase instruction level parallelism techniques such 
as pipelining, out of order execution and operand forwarding.  However 
these efforts come at a large power cost.  Out of order execution requires
a ReOrder Buffer (ROB), to commit the registers in program order.  This 
structure has grown to be monolithic with numerous entries and read/write ports.
There is no current methods to efficiently and equally compare various
ROB advancements to improve power efficiency. We propose a loosely cycle
accurate model that keeps track of the power usages of the ROB.  Using the 
simulation tool, we are able to compare and contrast the affects of improvements
made on the ROB.  This also allows for a first line test to validate proof of 
concepts for future power efficient ROB designs. 
\end{abstract}

\terms{Power, Energy, Architecture}

\keywords{Power efficiency, ROB, Simulation} % NOT required for Proceedings

\section{Introduction}
BLAH BLAH BLAH INTRO WEEEE
\section{Background}
    An out of order execution system has two additional stages 
to the lifetime of the instruction on top of the traditional pipeline 
stages.  Each of which a small memory array to keep track of instruction flow.
The first addition, the instruction queue(IQ) which holds instructions that are 
waiting to be executed.  Each entry will hold the instruction -- including 
type, operand registers, and destination registers.  The second structure 
holds the instructions that are in flight but not yet committed to the register
file. Each entry will hold both PC of the instruction, as well as the destination
register and the result of the execution unit.  There is also a flag that will
mark the result of the entry as valid.  

Replacing the traditional instruction dispatch stage, An placeholder will be made for the 
instruction in ReOrder Buffer (ROB), and the instructions will be placed
in the instruction queue(IQ). In this stage instructions will first wait for their operands if not already
available.  When all operands are available, the instruction is ready to 
be executed so wait until its appropriate execution unit is free.  At this 
point the instruction exits the IQ and begins execution.  

Upon execution completion, the output value is stored in the ROB with its 
corresponding entry and that entry is marked as valid or completed with a 
1 bit flag.  An entry is committed from the ROB to the architectural register
file (ARF) when that entry is the oldest (lowest PC) and its result has been 
marked as valid. 
\subsection{Circular ROB}
The circular ROB is one of the most basic implementations of the ROB.  Simply using
a circular buffer as the structure to hold each entry.  Since the ROB is basically
just memory, there are two special slots for to keep track of the head and tail
pointer to create the circular buffer.  As entries are written into the ROB, the
entry is written at the tail pointer and then the tail pointer is incremented.
Likewise when an entries is written to the ARF, the head pointer is incremented.
The circular buffer method is widely used since it inherently keeps track of the 
oldest instruction (which is at the head pointer), as well as which entry slots
are used or empty.   However it may not be very power efficient if there is a large
number of empty slots at any given point of the execution.    
\subsection{Dynamic ROB}

\subsection{Distributed ROB}

\subsection{Latch ROB}
In addition to large power requirement to maintain the entries of the ROB, another 
large power consumer is the read ports of the ROB.  The read port of the ROB is used
to forward the results of an entry to the dispatch unit (DU) to use as an operand.
All though forwarding from the ROB occurs about 6\%\cite{kucuk} of all instructions 
in an N way super scalar processor there are 2N ports (to accommodate FP
 instructions) which add unnecessary complexity and power consumption for a small 
percentage of instructions.  It has been proposed by eliminating the read ports 
in the ROB all together, we can reduce energy consumption\cite{kucuk}.  However
without read ports, a small window appears where the data cannot be accessed,
starting from when the result is placed in to the ROB until the ROB commits that 
entry to the ARF.  To help mitigate stalls that might happen due to this hole, 
we introduce retention latches.     

\section{Project Implementation}
Our simulator provides a cycle accurate behavioral model of a standard circular re-order buffer.  At the outset of the project, the standard re-order buffer we intended to implement was a non-circular RAM-based re-order buffer.  However, after feedback from the course instructor and students it was decided that a circular buffer is more widely held as being the 'standard' buffer type and would serve as an ideal underlying model for power optimizations.  Thus, we implement and compare the standard circular re-order buffer to circular re-order buffers with the following optimizations: 1) Distributed (Cluster based) ROB, 2) Dynamically Sized ROB, 3) Reduced Output Port ROB (Retention Latch). The following sections outline each of the above model implementations as well as input instruction generation and power results tabulation.  
\subsection{Instruction Generation}

\begin{table*}
\centering
\begin{tabular}{|c|c|c|c|} \hline
Instruction Type&Cycle Count&Instruction Type&Cycle Count\\ \hline
\texttt{LOAD}&20&\texttt{STORE}&20\\ \hline
\texttt{ADD}&1&\texttt{FADD}&3\\ \hline
\texttt{SUB}&1&\texttt{FSUB}&3\\ \hline
\texttt{MULT}&3&\texttt{FMULT}&5\\ \hline
\texttt{DIV}&18&\texttt{FDIV}&6\\ \hline\end{tabular}
\caption{Modeled instruction types and their corresponding completion cycle counts.}
\label{tab:instypetable}
\end{table*}

We model the input to our simulator as a stream of integer and floatpoint instructions.  The instructions are represented at the bit-level and model MIPS instructions as closely as possible.  Each instruction consists of 1) Instruction type, 2) Source and destination registers 3) a PC.  Table ~\ref{tab:instypetable} indicates the types of instructions modeled.  Each instruction type also has a predetermined cycle execution time designating the number of cycles that must elapse between instruction issue and the completion of the instruction.  As modeling functional units goes beyond the scope of this simulator, instructions are flagged as complete after the listed number of cycles has elapsed.  The actual cycle counts are the same as those modeled in MIT's Graphite many-core processor simulator\cite{graphite}, with the exception of LOAD and STORE.  The cycle counts corresponding to LOAD and STORE instructions are estimated as a predetermined 20 cycles each.  This is simply an estimation as the actual cycle count is heavily dependent on cache architecture and benchmark specific cache behavior.  Since both of these topics are beyond the scope of the simulator, we estimate the completion time of LOAD and STORE instructions as a set value substantially longer than the other more accurate instruction types.

Registers are generated in bit representation as 4 bits each totaling 12 bits for the s1, s2 and d registers in each instruction. Currently, our representation of instructions make no distinction between zero, 1, and 2 operand instructions.  All instructions regardless of type feature two operands.  This feature is supported by the fact that a memory hierarchy and functional units are not simulated by our system and as such immediate values have no direct use.  Further, every instruction features a d register regardless of type.  Because our simulator features operand forwarding from the ROB, it is necessary for the generation of registers to keep track of past destination registers to use as dependent operands in future instructions.  This history buffer is implemented as a rotating bit register from which prior destination registers can be indexed.

Each instruction also features a program counter associated with the instruction.  While this is clearly a simplification of a real system, it serves the purposes of our simulation as a uniquely identifiable tag by which to differentiate instructions.  In both a real system and our simulator, a statically set 32 bit value is used to represent this PC/tag.  As such, the specific values contained in the PC/tag will yield accurate transition results (nonexistent) and is thus are irrelevant.  Simply starting the PC of the first instruction in the stream at 0 and incrementing by 4 each instruction guarantees uniqueness among PCs and serves the purposes of an instruction tag.

The aforementioned instruction fields have multiple modes of generation.  Our simulator synthetically generates an instruction input trace based on a prescribed instruction profile.  The instruction profile features: 1) a percent rate of occurrence for each instruction type, 2) a rate corresponding to the interdependence of registers between instructions, and 3) an overall instruction count.  

The instruction generator is currently capable of generating four distinct instruction streams corresponding to different instruction workloads.  The first instruction stream is marked as the default instruction stream.  It features equal percentages of each type of instruction as well as a 10% register dependence rate.  This register dependence rate was selected arbitrarily to act as a starting point for modeling data dependencies between instructions.

The remaining three instruction streams are modeled after SPEC-FP benchmarks \cite{rupnow}.  The benchmarks were chosen to represent three major modes of operation:  floating point heavy execution, integer heavy execution, and mixed type execution.  For a floating point heavy execution, 173.applu was selected and modeled.  173.applu models parabolic/elliptical partial differential equations and features almost exclusively floating point operations as well as a large number of memory operations making it useful as both a floating point benchmark as well as a long running memory intensive benchmark.  191.fma3d is used to model integer heavy execution.  It models finite-element crash simulation and features very few floating point operations and substantially fewer memory operations than 173.applu making it an ideal light-weight integer workload.  Finally, 183.equake is used to represent the average workload.  It models seismic wave propagation and features both integer and floating point operations as well as moderate memory usage.  As such it acts as a more representative general workload than the original default workload.  Each of the SPEC-FP benchmarks feature a 6{\char'045} register forwarding frequency as is reported by \cite{kucuk}.

\begin{table*}
\centering
\begin{tabular}{|c|c|c|c|c|} \hline
ins{\char'137}profile&default{\char'137}profile&173{\char'056}applu&191{\char'056}fma3d&183{\char'056}equake\\ \hline
loadProc&0.10&0.32&0.12&0.37\\ \hline
storeProc&0.10&0.12&0.24&0.06\\ \hline
addProc&0.10&0.01&0.15&0.08\\ \hline
subProc&0.10&0.01&0.15&0.08\\ \hline
multProc&0.10&0.01&0.15&0.08\\ \hline
divProc&0.10&0.01&0.15&0.08\\ \hline
faddProc&0.10&0.13&0.01&0.07\\ \hline
fsubProc&0.10&0.13&0.01&0.06\\ \hline
fmultProc&0.10&0.13&0.01&0.06\\ \hline
fdivProc&0.10&0.13&0.01&0.06\\ \hline
forwardingRate&0.10&0.06&0.06&0.06\\ \hline
instCount&10000&10000&10000&10000\\ \hline\end{tabular}
\caption{Benchmark Instruction Profiles showing percent rate of occurrence of each instruction type.}
\label{tab:insprofile}
\end{table*}

For the purposes of our power comparisons, each of the above instruction workloads are normalized to generate 10000 instructions.  Such a large instruction window is ideal to allow buffers to fill and behavioral characteristics to develop.  The specific values used for each workload are listed in Table ~\ref{tab:insprofile}.
\subsection{Model Implementation}
The following section details the model implementatations in our simulator.  The basic re-order buffer model we use as a base-line for comparison is a standard circular ROB model.  Section ~\ref{sec:circ} discusses its implementation.  We further model three optimizations for re-order buffers in an attempt to improve overall power usage: 1) Distributed (Cluster based) ROB, 2) Dynamically Sized ROB, 3) Reduced Output Port ROB (Retention Latch).  Each of these optimized models are built on top of the underlying circular ROB model to provide as close a behavioral and power comparison as possible.  Each of the optimizations, as well as the standard circular reorder buffer, are described in detail below.
\subsubsection{Circular ROB}
\label{sec:circ}
\subsubsection{Distributed (Cluster based) ROB}
\subsubsection{Dynamically Sized ROB}
\subsubsection{Reduced Output Port ROB (Retention Latch)}
\subsection{Power Tabulation Implementation}
\section{Results}
hi
\subsection{subsection titl}
sub section.. with table!
\begin{table*}
\centering
\caption{Some Typical Commands}
\begin{tabular}{|c|c|l|} \hline
Command&A Number&Comments\\ \hline
\texttt{{\char'134}alignauthor} & 100& Author alignment\\ \hline
\texttt{{\char'134}numberofauthors}& 200& Author enumeration\\ \hline
\texttt{{\char'134}table}& 300 & For tables\\ \hline
\texttt{{\char'134}table*}& 400& For wider tables\\ \hline\end{tabular}
\end{table*}
% end the environment with {table*}, NOTE not {table}!

\section{Conclusions}
ending stuff
%\end{document}  % This is where a 'short' article might terminate

%ACKNOWLEDGMENTS are optional
\section{Acknowledgments}
if we really need this....

%TODO add in bib 
\begin{thebibliography}{------}
\bibitem{graphite}
	MIT Graphite Simulator
	https://github.com/mit-carbon/Graphite/wiki
\bibitem{kucuk}
Gurhan Kucuk, Dmitry Ponomarev, and Kanad Ghose. 2002. Low-complexity reorder buffer architecture. In Proceedings
of the 16th international conference on Supercomputing (ICS '02). ACM, New York, NY, USA, 57-66. DOI=10.
1145/514191.514202 http://doi.acm.org/10.1145/514191.514202
\bibitem{rupnow}
Kyle Rupnow, Arun Rodrigues, Keith Underwood, and Katherine Compton. 2006. Scientific applications vs. SPEC-FP: a comparison of program behavior. In Proceedings of the 20th annual international conference on Supercomputing (ICS '06). ACM, New York, NY, USA, 66-74. DOI=10.1145/1183401.1183413 http://doi.acm.org/10.1145/1183401.1183413 


\end{thebibliography}
\end{document}
